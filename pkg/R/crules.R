setClass("crules", representation(rules = "list",  yname = "character",
				ylevels = "character", xnames = "character",
				xlevels = "list", xtypes = "character",
				call = "call"))


.crules.print <- function(x){
	print(data.frame(Rule = x@rules$Rules, Precision = x@rules$RulesPrecisions, 
					Coverage = x@rules$RulesCoverages, "P-value" = x@rules$Pvalues), 
			right = FALSE)
}

setMethod("print", "crules", .crules.print)
setMethod("show", "crules", .crules.print)

.prepare.data <- function(formula, data, q, qsplit, weights){
	#measures
	q.names = c("g2", "lift", "ls", "rss", "corr", "s", "c1", "c2", "cn2", "gain")
	qsplit.names <- c(q.names, "entropy")
	
	if(is.character(q)){	
		q <- match.arg(q, q.names)
		qfun <- NULL
	}
	else if(is.function(q)){
		if(length(formals(q)) != 4) stop("Custom rule quality measure must be a function with four parameters")
		qfun <- q
		qsplit  #forcing the promise
		q <- ""
	}
	if(is.character(qsplit)){
		qsplit <- match.arg(qsplit, qsplit.names)
		qsplitfun <- NULL
	}
	else if(is.function(qsplit)){
		if(length(formals(qsplit)) != 4) stop("Custom rule quality measure must be a function with four parameters")
		qsplitfun <- qsplit
		qsplit <- ""
	}
	
	#data evaluation
	mf <- model.frame(formula, data, na.action=na.pass)
	y <- mf[,1, drop=TRUE]
	if(is.factor(y) || is.character(y) || is.logical(y)){
		y <- as.factor(y)
	}
	else
		stop("Decision attribute can only be of factor, character or logical type")
	
	x <- mf[,-1, drop=FALSE]
	
	#weights:
	weights <- .check.weights(weights)
	
	#levels, names, types
	yname <- names(mf[,1, drop=FALSE])
	ylevels <- levels(y)
	xdata <- .prepare.xdata(x)
	
	list(y = y, yname = yname, ylevels = ylevels, x = x, xtypes = xdata$xtypes, xnames = xdata$xnames,
			xlevels = xdata$xlevels, q = q, qsplit = qsplit, qfun = qfun, qsplitfun = qsplitfun,
			weights = weights)
}

.check.weights <- function(weights){
	if(missing(weights))
		return(vector("numeric"))
	else if(length(weights) != length(y))
		stop("weights vector should be the same length as the number of examples")
	else if(any(weights <= 0))
		stop("weights cannot be negative numbers")
}

.prepare.xdata <- function(x){
	xncol <- ncol(x)
	xnames <- vector("character", xncol)
	xtypes <- vector("character", xncol)
	xlevels <- vector("list", xncol)
	for(i in 1:xncol){
		xnames[i] <- names(x)[i]
		if(is.numeric(x[,i])){
			xtypes[i] <- "numeric"
		}
		else if(is.factor(x[,i]) || is.character(x[,i]) || is.logical(x[,i])){
			xtypes[i] <- "factor"
			x[,i] <- as.factor(x[,i])
			xlevels[[i]] <- levels(x[,i])
		}
		else
			stop("Conditional attributes can only be of numeric, factor, character or logical type")
	}
	list(xnames = xnames, xtypes = xtypes, xlevels = xlevels)
}

crules <- function(formula, data, q, qsplit = q, weights)
{
	par <- .prepare.data(formula, data, q, qsplit, weights)
	#create object and call the method
	rarc <- new( RInterface)
	rules <- rarc$generateRules( par$y, par$yname, par$ylevels,  par$x, par$xtypes, 
			par$xnames, par$xlevels, 
			par$q, par$qsplit, par$qfun, par$qsplitfun, 
			par$weights, runif(1) )
	#return object of crules class
	new("crules", rules = rules,  yname = par$yname,
			ylevels = par$ylevels, xnames = par$xnames,
			xlevels = par$xlevels, xtypes = par$xtypes, call = match.call(expand.dots = FALSE))
}

setMethod("summary", "crules", function(object){
			value <- vector("numeric", 5)
			value[1] <- length(object@rules$NumbersOfConditions)
			value[2] <- mean(object@rules$NumbersOfConditions)
			value[3] <- mean(object@rules$RulesPrecisions)
			value[4] <- mean(object@rules$RulesCoverages)
			value[5] <- mean(object@rules$Pvalues)
			data.frame(value, row.names = c("Number of rules:", 
							"Average number of elementary conditions per rule:",
							"Average precision of rules:",
							"Average coverage of rules:",
							"Average p-value of rules:"))
		})

.prep.pred.res <- function(preds, classes){
	preds$predictions <- factor(classes[preds$predictions + 1], levels = classes)
	
	if(length(preds$confusionMatrix) > 0)
	{
		cm.names <- list(Actual = classes,
				Predicted = classes)
		cm <- matrix(unlist(preds$confusionMatrix),
				ncol=length(preds$confusionMatrix[[1]]),
				byrow=TRUE, dimnames = cm.names)
		
		addInfo <- matrix(c(preds$unclassified, preds$classesAccuracies), 
				ncol = 2, dimnames = list(classes, 
						c("Unknown", "Class accuracy")))
		preds$confusionMatrix <- cbind(cm, addInfo)
		names(dimnames(preds$confusionMatrix)) <- c("Actual", "Predicted")
	}
	else
	{
		preds$confusionMatrix <- NULL
		preds$acc <- NULL
		preds$bac <- NULL
	}
	
	preds$classesAccuracies <- NULL
	preds$unclassified <- NULL
	preds
}

setMethod("predict", "crules", function(object, newdata, weights){
			yindex <- match(object@yname, names(newdata))
			if(is.na(yindex))
				y <- vector("numeric")
			else
				y <- newdata[,yindex]
			
			#weights:
			weights <- .check.weights(weights)
			
			cols <- match(object@xnames, names(newdata))
			x <- newdata[cols]
			xdata <- .prepare.xdata(x)
			
			if(length(xdata$xnames) < length(object@xnames))
				stop("Attributes in new data should match attributes used to generate rules")
			
			rarc <- new( RInterface)
			preds <- rarc$predict(y, object@yname, object@ylevels, x, xdata$xtypes, xdata$xnames, 
					xdata$xlevels, object@rules$Rules, object@rules$ConfidenceDegrees, weights, runif(1))
			
			
			.prep.pred.res(preds, object@ylevels)
		})
